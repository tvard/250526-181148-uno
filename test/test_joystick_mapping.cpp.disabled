/*
 * Unit Tests for Joystick Mapping Functionality
 * Tests the fixes implemented for joystick range and fill bar behavior
 */

#include <unity.h>
#include <stdint.h>

// Arduino compatibility for native environment
#ifndef ARDUINO
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define abs(x) ((x)>0?(x):-(x))
#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
long map(long x, long in_min, long in_max, long out_min, long out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
#endif

// Mock the display functions for testing
class MockDisplay {
public:
    static int lastThrottlePercent;
    static int lastLeftRightPercent;
    static int lastFillStartX;
    static int lastFillWidth;
    static bool fillFromCenter;
    
    static void resetMocks() {
        lastThrottlePercent = -1;
        lastLeftRightPercent = 0;
        lastFillStartX = -1;
        lastFillWidth = -1;
        fillFromCenter = false;
    }
};

int MockDisplay::lastThrottlePercent = -1;
int MockDisplay::lastLeftRightPercent = 0;
int MockDisplay::lastFillStartX = -1;
int MockDisplay::lastFillWidth = -1;
bool MockDisplay::fillFromCenter = false;

// Mock functions to replace the display drawing functions
void drawThrottle(int throttlePercent, int barX, int barY, int offsetX) {
    MockDisplay::lastThrottlePercent = throttlePercent;
}

void drawLeftRightBar(int leftRightPercent, int barX, int barY, int offsetX) {
    MockDisplay::lastLeftRightPercent = leftRightPercent;
}

// Test constants and variables from the main code
const uint16_t RANGE_EXPANSION_FACTOR = 50;
uint16_t xMin = 512, xMax = 512;
uint16_t yMin = 512, yMax = 512;
uint16_t xCenter = 512, yCenter = 512;

// Helper function to simulate joystick mapping logic
void simulateJoystickReading(uint16_t x, uint16_t y) {
    // Update dynamic range tracking (same logic as main code)
    if (x < xMin) {
        xMin = max(0, (int)x - RANGE_EXPANSION_FACTOR);
    }
    if (x > xMax) {
        xMax = min(1023, (int)x + RANGE_EXPANSION_FACTOR);
    }
    if (y < yMin) {
        yMin = max(0, (int)y - RANGE_EXPANSION_FACTOR);
    }
    if (y > yMax) {
        yMax = min(1023, (int)y + RANGE_EXPANSION_FACTOR);
    }

    // Throttle calculation (same logic as main code)
    int throttlePercent;
    if (abs((int)y - (int)yCenter) < 15) {
        throttlePercent = 50;
    } else if (y > yCenter) {
        throttlePercent = map(y, yCenter, yMax, 50, 100);
    } else {
        throttlePercent = map(y, yMin, yCenter, 0, 50);
    }
    throttlePercent = constrain(throttlePercent, 0, 100);
    drawThrottle(throttlePercent, 0, 18, 30);

    // Left/Right calculation (same logic as main code)
    int leftRightPercent;
    if (abs((int)x - (int)xCenter) < 15) {
        leftRightPercent = 0;
    } else if (x > xCenter) {
        leftRightPercent = map(x, xCenter, xMax, 0, 100);
    } else {
        leftRightPercent = map(x, xMin, xCenter, -100, 0);
    }
    leftRightPercent = constrain(leftRightPercent, -100, 100);
    drawLeftRightBar(leftRightPercent, 0, 26, 30);
}

void setUp(void) {
    // Reset all test variables before each test
    MockDisplay::resetMocks();
    xMin = 512; xMax = 512;
    yMin = 512; yMax = 512;
    xCenter = 512; yCenter = 512;
    
    // Initialize with reasonable starting range (same as main code)
    xMin = max(0, (int)xCenter - 200);
    xMax = min(1023, (int)xCenter + 200);
    yMin = max(0, (int)yCenter - 200);
    yMax = min(1023, (int)yCenter + 200);
}

void tearDown(void) {
    // Clean up after each test
}

// Test 1: Center position should show 50% throttle and 0% left/right
void test_joystick_center_position(void) {
    simulateJoystickReading(512, 512);
    
    TEST_ASSERT_EQUAL_INT(50, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(0, MockDisplay::lastLeftRightPercent);
}

// Test 2: Full forward should show 100% throttle
void test_joystick_full_forward(void) {
    // Simulate maximum Y value
    simulateJoystickReading(512, 1023);
    
    TEST_ASSERT_EQUAL_INT(100, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(0, MockDisplay::lastLeftRightPercent);
}

// Test 3: Full reverse should show 0% throttle
void test_joystick_full_reverse(void) {
    // Simulate minimum Y value
    simulateJoystickReading(512, 0);
    
    TEST_ASSERT_EQUAL_INT(0, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(0, MockDisplay::lastLeftRightPercent);
}

// Test 4: Full right should show 100% left/right
void test_joystick_full_right(void) {
    // Simulate maximum X value
    simulateJoystickReading(1023, 512);
    
    TEST_ASSERT_EQUAL_INT(50, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(100, MockDisplay::lastLeftRightPercent);
}

// Test 5: Full left should show -100% left/right
void test_joystick_full_left(void) {
    // Simulate minimum X value
    simulateJoystickReading(0, 512);
    
    TEST_ASSERT_EQUAL_INT(50, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(-100, MockDisplay::lastLeftRightPercent);
}

// Test 6: Range expansion works correctly
void test_range_expansion(void) {
    uint16_t initialXMax = xMax;
    uint16_t initialYMax = yMax;
    
    // Simulate reading beyond current range
    simulateJoystickReading(800, 800);
    
    // Range should have expanded
    TEST_ASSERT_GREATER_THAN(initialXMax, xMax);
    TEST_ASSERT_GREATER_THAN(initialYMax, yMax);
    
    // And the expansion should be by at least the expansion factor
    TEST_ASSERT_GREATER_OR_EQUAL(800 + RANGE_EXPANSION_FACTOR, xMax);
    TEST_ASSERT_GREATER_OR_EQUAL(800 + RANGE_EXPANSION_FACTOR, yMax);
}

// Test 7: Deadzone functionality
void test_deadzone_functionality(void) {
    // Test values within deadzone (±14 from center)
    simulateJoystickReading(512 + 10, 512 - 10);
    
    TEST_ASSERT_EQUAL_INT(50, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(0, MockDisplay::lastLeftRightPercent);
    
    // Test values just outside deadzone (±16 from center)
    simulateJoystickReading(512 + 16, 512 + 16);
    
    TEST_ASSERT_NOT_EQUAL(50, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_NOT_EQUAL(0, MockDisplay::lastLeftRightPercent);
}

// Test 8: Gradual progression (not instant max)
void test_gradual_progression(void) {
    // Test incremental movement should show gradual increase
    simulateJoystickReading(512, 600);  // Small forward movement
    int throttle1 = MockDisplay::lastThrottlePercent;
    
    simulateJoystickReading(512, 700);  // Larger forward movement
    int throttle2 = MockDisplay::lastThrottlePercent;
    
    simulateJoystickReading(512, 800);  // Even larger forward movement
    int throttle3 = MockDisplay::lastThrottlePercent;
    
    // Should show progression: 50 < throttle1 < throttle2 < throttle3 <= 100
    TEST_ASSERT_GREATER_THAN(50, throttle1);
    TEST_ASSERT_GREATER_THAN(throttle1, throttle2);
    TEST_ASSERT_GREATER_THAN(throttle2, throttle3);
    TEST_ASSERT_LESS_OR_EQUAL(100, throttle3);
}

// Test 9: Symmetric behavior for left/right
void test_symmetric_left_right_behavior(void) {
    // Test equal magnitude movements left and right
    simulateJoystickReading(400, 512);  // Left movement
    int leftPercent = MockDisplay::lastLeftRightPercent;
    
    simulateJoystickReading(624, 512);  // Right movement (same distance from center)
    int rightPercent = MockDisplay::lastLeftRightPercent;
    
    // Should be symmetric: leftPercent should be negative rightPercent
    TEST_ASSERT_EQUAL_INT(-leftPercent, rightPercent);
}

// Test 10: Boundary conditions
void test_boundary_conditions(void) {
    // Test extreme values
    simulateJoystickReading(0, 0);
    TEST_ASSERT_EQUAL_INT(0, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(-100, MockDisplay::lastLeftRightPercent);
    
    simulateJoystickReading(1023, 1023);
    TEST_ASSERT_EQUAL_INT(100, MockDisplay::lastThrottlePercent);
    TEST_ASSERT_EQUAL_INT(100, MockDisplay::lastLeftRightPercent);
}

int main() {
    UNITY_BEGIN();
    
    // Run all tests
    RUN_TEST(test_joystick_center_position);
    RUN_TEST(test_joystick_full_forward);
    RUN_TEST(test_joystick_full_reverse);
    RUN_TEST(test_joystick_full_right);
    RUN_TEST(test_joystick_full_left);
    RUN_TEST(test_range_expansion);
    RUN_TEST(test_deadzone_functionality);
    RUN_TEST(test_gradual_progression);
    RUN_TEST(test_symmetric_left_right_behavior);
    RUN_TEST(test_boundary_conditions);
    
    return UNITY_END();
}
